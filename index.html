<!DOCTYPE html>
<html lang="en">

<head>
	<title>Free Cam test</title>
	<meta charset=utf-8 />
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>
	<div id="info">
		<br />
		<span class="desktop-controls"></span>
		<span class="mobile-controls" style="display: none;"></span>
	</div>
	<div id="container"></div>


	<script type="importmap">
		{
				"imports": {
					"three": "https://unpkg.com/three@0.160.0/build/three.module.js",
					"three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
					"cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
				}
			}
		</script>

	<script type="module">

		import * as THREE from 'three';
		import * as CANNON from 'cannon-es';

			import Stats from 'three/addons/libs/stats.module.js';

			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
			import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
			import { SSAOPass } from 'three/addons/postprocessing/SSAOPass.js';
			import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
			import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
			import { LUTPass } from 'three/addons/postprocessing/LUTPass.js';
			import { LUTCubeLoader } from 'three/addons/loaders/LUTCubeLoader.js';
			import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
			import { Water } from 'three/addons/objects/Water2.js';

			/** Consolidated post-processing shader (vignette, tilt-shift, film grain) */
			const MasterPostShader = {
				uniforms: {
					'tDiffuse': { value: null },
					'time': { value: 0.0 },
					'resolution': { value: new THREE.Vector2( window.innerWidth, window.innerHeight ) },
					'vignetteEnabled': { value: true },
					'vignetteOffset': { value: 1.0 },
					'vignetteDarkness': { value: 1.2 },
					'grainEnabled': { value: true },
					'grainIntensity': { value: 0.15 },
					'tiltShiftEnabled': { value: false },
					'focusY': { value: 0.5 },
					'focusWidth': { value: 0.35 },
					'blurAmount': { value: 2.0 }
				},
				vertexShader: `
					varying vec2 vUv;
					void main() {
						vUv = uv;
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
					}
				`,
				fragmentShader: `
					uniform sampler2D tDiffuse;
					uniform float time;
					uniform vec2 resolution;
					uniform bool vignetteEnabled;
					uniform float vignetteOffset;
					uniform float vignetteDarkness;
					uniform bool grainEnabled;
					uniform float grainIntensity;
					uniform bool tiltShiftEnabled;
					uniform float focusY;
					uniform float focusWidth;
					uniform float blurAmount;
					varying vec2 vUv;
					
					float rand( vec2 co ) {
						return fract( sin( dot( co.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );
					}
					
					void main() {
						vec2 texelSize = 1.0 / resolution;
						vec4 color;
						
						if ( tiltShiftEnabled && blurAmount > 0.0 ) {
							float dist = abs( vUv.y - focusY );
							float blur = smoothstep( 0.0, focusWidth, dist ) * blurAmount;
							vec4 sum = vec4( 0.0 );
							float total = 0.0;
							for ( float i = -2.0; i <= 2.0; i++ ) {
								float weight = 1.0 - abs( i ) / 2.0;
								vec2 offset = vec2( 0.0, i * blur * texelSize.y );
								sum += texture2D( tDiffuse, vUv + offset ) * weight;
								total += weight;
							}
							for ( float i = -2.0; i <= 2.0; i++ ) {
								float weight = 1.0 - abs( i ) / 2.0;
								vec2 offset = vec2( i * blur * texelSize.x * 0.5, 0.0 );
								sum += texture2D( tDiffuse, vUv + offset ) * weight;
								total += weight;
							}
							color = sum / total;
						} else {
							color = texture2D( tDiffuse, vUv );
						}
						
						if ( grainEnabled && grainIntensity > 0.0 ) {
							float grain = rand( vUv + fract( time ) ) * 2.0 - 1.0;
							color.rgb += grain * grainIntensity;
						}
						
						if ( vignetteEnabled ) {
							vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( vignetteOffset );
							float vignette = 1.0 - dot( uv, uv );
							vignette = clamp( pow( vignette, vignetteDarkness ), 0.0, 1.0 );
							color.rgb *= vignette;
						}
						
						gl_FragColor = color;
					}
				`
			};

			const clock = new THREE.Clock();
			const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test( navigator.userAgent );

			const scene = new THREE.Scene();
			scene.background = new THREE.Color( 0x88ccee );
			scene.fog = new THREE.Fog( 0x88ccee, 0, isMobileDevice ? 30 : 50 );

			const camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 200 );
			camera.rotation.order = 'YXZ';

			const fillLight1 = new THREE.HemisphereLight( 0x8dc1de, 0x00668d, 1.5 );
			fillLight1.position.set( 2, 1, 1 );
			scene.add( fillLight1 );

			const light = new THREE.PointLight( 0xff0000, 100, 0 );
			light.position.set( -7, 6, 60 );
			light.castShadow = true;
			scene.add( light );

			const sun = new THREE.PointLight( 0xff0000, 1000, 0 );
			sun.position.set( 50, 1, 200 );
			sun.castShadow = true;
			scene.add( light );

			const directionalLight = new THREE.DirectionalLight( 0xffffff, 2.5 );
			directionalLight.position.set( -5, 25, -1 );
			directionalLight.castShadow = true;
			directionalLight.shadow.camera.near = 0.1;
			directionalLight.shadow.camera.far = 100;
			directionalLight.shadow.camera.right = 20;
			directionalLight.shadow.camera.left = -20;
			directionalLight.shadow.camera.top = 20;
			directionalLight.shadow.camera.bottom = -20;
			const shadowRes = isMobileDevice ? 256 : 512;
			directionalLight.shadow.mapSize.width = shadowRes;
			directionalLight.shadow.mapSize.height = shadowRes;
			directionalLight.shadow.radius = 2;
			directionalLight.shadow.bias = -0.0001;
			directionalLight.shadow.autoUpdate = false;
			directionalLight.shadow.needsUpdate = true;
			scene.add( directionalLight );

			const ambientLight = new THREE.AmbientLight( 0x404040, 0.5 );
			scene.add( ambientLight );

			/** Water plane */
			let water = null;
			const textureLoader = new THREE.TextureLoader();
			const waterParams = { color: 0x0088aa, scale: 4, flowX: 1, flowY: 1 };
			const waterTextureBase = 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/water/';
			
			const container = document.getElementById( 'container' );
			const isMobile = isMobileDevice;
			
			/** Water - full shader on all platforms, optimizations only affect other systems */
			Promise.all( [
				new Promise( ( resolve ) => {
					textureLoader.load( waterTextureBase + 'Water_1_M_Normal.jpg', ( tex ) => {
						tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
						resolve( tex );
					}, undefined, () => resolve( null ) );
				} ),
				new Promise( ( resolve ) => {
					textureLoader.load( waterTextureBase + 'Water_2_M_Normal.jpg', ( tex ) => {
						tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
						resolve( tex );
					}, undefined, () => resolve( null ) );
				} )
			] ).then( ( [ normalMap0, normalMap1 ] ) => {
				if ( normalMap0 && normalMap1 ) {
					const waterGeometry = new THREE.PlaneGeometry( 500, 500 );
					water = new Water( waterGeometry, {
						color: waterParams.color,
						scale: waterParams.scale,
						flowDirection: new THREE.Vector2( waterParams.flowX, waterParams.flowY ),
						normalMap0: normalMap0,
						normalMap1: normalMap1
					} );
					water.position.set( 0, -0.1, 0 );
					water.rotation.x = Math.PI * -0.5;
					scene.add( water );
				}
			} );

			const renderer = new THREE.WebGLRenderer( { 
				antialias: !isMobile,
				powerPreference: isMobile ? 'low-power' : 'high-performance',
				precision: isMobile ? 'mediump' : 'highp'
			} );
			renderer.setPixelRatio( isMobile ? 1.0 : Math.min( window.devicePixelRatio, 1.5 ) );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setAnimationLoop( animate );
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = isMobile ? THREE.BasicShadowMap : THREE.PCFSoftShadowMap;
			renderer.toneMapping = THREE.ACESFilmicToneMapping;
			renderer.toneMappingExposure = 1.0;
			container.appendChild( renderer.domElement );

			/** Stats and coordinates display - enabled for both mobile and desktop */
			let stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			container.appendChild( stats.domElement );

			let coordsDisplay = document.createElement( 'div' );
			coordsDisplay.style.cssText = 'position:absolute;top:50px;left:0;background:rgba(0,0,0,0.7);color:#fff;padding:8px 12px;font:12px monospace;z-index:100;border-radius:0 4px 4px 0;';
			coordsDisplay.innerHTML = 'X: 0.00<br>Y: 0.00<br>Z: 0.00';
			container.appendChild( coordsDisplay );

			/** Post-processing pipeline */
			const composer = new EffectComposer( renderer );

			const renderPass = new RenderPass( scene, camera );
			composer.addPass( renderPass );

			const ssaoPass = new SSAOPass( scene, camera, 
				Math.floor( window.innerWidth / 2 ), 
				Math.floor( window.innerHeight / 2 ) 
			);
			ssaoPass.kernelRadius = 8;
			ssaoPass.minDistance = 0.001;
			ssaoPass.maxDistance = 0.05;
			ssaoPass.output = SSAOPass.OUTPUT.Default;
			composer.addPass( ssaoPass );

			const bloomPass = new UnrealBloomPass(
				new THREE.Vector2( window.innerWidth, window.innerHeight ),
				0.3, 0.4, 0.92
			);
			composer.addPass( bloomPass );

			const masterPostPass = new ShaderPass( MasterPostShader );
			masterPostPass.uniforms[ 'resolution' ].value.set( window.innerWidth, window.innerHeight );
			composer.addPass( masterPostPass );

			let lutPass = null;
			const lutLoader = new LUTCubeLoader();
			const lutSettings = { enabled: true, intensity: 1.0 };

			lutLoader.load( './HardBoost.cube', ( result ) => {
				lutPass = new LUTPass( { lut: result.texture3D, intensity: lutSettings.intensity } );
				composer.insertPass( lutPass, composer.passes.length - 1 );
			} );

			const outputPass = new OutputPass();
			composer.addPass( outputPass );

			const postProcessingSettings = {
				ssaoEnabled: false,
				ssaoKernelRadius: 8,
				ssaoMinDistance: 0.001,
				ssaoMaxDistance: 0.05,
				bloomEnabled: true,
				bloomStrength: 0.2,
				bloomRadius: 1,
				bloomThreshold: 0.92,
				filmEnabled: true,
				filmNoiseIntensity: 0.07,
				vignetteEnabled: true,
				vignetteOffset: 1.0,
				vignetteDarkness: 1.2,
				tiltShiftEnabled: false,
				tiltShiftFocusY: 0.5,
				tiltShiftFocusWidth: 0.35,
				tiltShiftBlurAmount: 2.0,
				lutEnabled: true,
				lutIntensity: 0.8
			};

			const PHYSICS_TIMESTEP = 1/60;
			const SPAWN_POSITION = { x: 0, y: 5, z: 0 };
			const PLAYER_HEIGHT = 1.8;
			const PLAYER_RADIUS = 0.4;
			const PLAYER_EYE_HEIGHT = 1.6;
			let cameraMode = 'firstPerson';

			/** Default environment settings */
			const defaultEnvSettings = {
				backgroundColor: '#88ccee',
				fogEnabled: false,
				fogColor: '#88ccee',
				fogNear: 0,
				fogFar: 50,
				hemiSkyColor: '#ffffff',
				hemiGroundColor: '#00668d',
				hemiIntensity: 0,
				sunColor: '#ffffff',
				sunIntensity: 0,
				sunPosX: -5,
				sunPosY: 25,
				sunPosZ: -1,
				ambientColor: '#ffffff',
				ambientIntensity: 1.1,
				toneMapping: 'ACESFilmic',
				exposure: 1.0,
				showCollisionWireframe: false,
				showColliderVisualization: false,
				cameraMode: 'firstPerson',
				thirdPersonDistance: 5,
				thirdPersonHeight: 2,
				thirdPersonAngle: 0.3,
				moveSpeed: 9,
				acceleration: 50,
				deceleration: 30,
				gravity: 25,
				jumpVelocity: 6,
				friction: 0,
				airControl: 0.3,
				playerMass: 10,
				cameraSmoothing: 30
			};

			function loadSettings() {
				try {
					const saved = localStorage.getItem( 'envSettings' );
					if ( saved ) return { ...defaultEnvSettings, ...JSON.parse( saved ) };
				} catch ( e ) { console.warn( 'Failed to load settings:', e ); }
				return { ...defaultEnvSettings };
			}

			function saveSettings() {
				try { localStorage.setItem( 'envSettings', JSON.stringify( envSettings ) ); }
				catch ( e ) { console.warn( 'Failed to save settings:', e ); }
			}
/**
 * Creates a debounced function that delays invoking func until after 
 * wait milliseconds have elapsed since the last time the debounced function 
 * was invoked.
 *
 * @param {Function} func The function to debounce.
 * @param {number} wait The number of milliseconds to wait (cooldown period).
 * @returns {Function} A new, debounced function.
 */
 function debounce(func, wait = 250) {
    let timeoutId;

    return function(...args) {
        // 'this' context is preserved using apply or call
        const context = this; 

        // Clear the previous timeout if the function is called again
        clearTimeout(timeoutId); 

        // Set a new timeout to execute the function after the wait period
        timeoutId = setTimeout(() => {
            func.apply(context, args);
        }, wait);
    };
}
			const envSettings = loadSettings();

			/** Physics world */
			const world = new CANNON.World();
			world.gravity.set( 0, -envSettings.gravity, 0 );
			world.broadphase = new CANNON.SAPBroadphase( world );
			world.allowSleep = false;
			world.solver.iterations = 10;

			const groundMaterial = new CANNON.Material( 'ground' );
			const playerMaterial = new CANNON.Material( 'player' );
			const playerGroundContact = new CANNON.ContactMaterial( playerMaterial, groundMaterial, {
				friction: envSettings.friction,
				restitution: 0.0
			} );
			world.addContactMaterial( playerGroundContact );

			const playerBody = new CANNON.Body( {
				mass: envSettings.playerMass,
				material: playerMaterial,
				linearDamping: 0.01,
				angularDamping: 1.0,
				fixedRotation: true,
				position: new CANNON.Vec3( SPAWN_POSITION.x, SPAWN_POSITION.y, SPAWN_POSITION.z )
			} );

			const cylinderHeight = PLAYER_HEIGHT - PLAYER_RADIUS * 2;
			const cylinderShape = new CANNON.Cylinder( PLAYER_RADIUS, PLAYER_RADIUS, cylinderHeight, 8 );
			const topSphereShape = new CANNON.Sphere( PLAYER_RADIUS );
			const bottomSphereShape = new CANNON.Sphere( PLAYER_RADIUS );

			const cylinderQuaternion = new CANNON.Quaternion();
			cylinderQuaternion.setFromAxisAngle( new CANNON.Vec3( 1, 0, 0 ), Math.PI / 2 );
			playerBody.addShape( cylinderShape, new CANNON.Vec3( 0, 0, 0 ), cylinderQuaternion );
			playerBody.addShape( topSphereShape, new CANNON.Vec3( 0, cylinderHeight / 2, 0 ) );
			playerBody.addShape( bottomSphereShape, new CANNON.Vec3( 0, -cylinderHeight / 2, 0 ) );
			world.addBody( playerBody );

			let playerOnFloor = false;
			let groundContactNormal = new CANNON.Vec3();
			const upAxis = new CANNON.Vec3( 0, 1, 0 );

			playerBody.addEventListener( 'collide', ( event ) => {
				const contact = event.contact;
				let contactNormal;
				if ( contact.bi.id === playerBody.id ) {
					contactNormal = contact.ni.negate( new CANNON.Vec3() );
				} else {
					contactNormal = contact.ni;
				}
				if ( contactNormal.dot( upAxis ) > 0.5 ) {
					playerOnFloor = true;
					groundContactNormal.copy( contactNormal );
				}
			} );

			const playerDirection = new THREE.Vector3();
			const keyStates = {};

			function applySettings() {
				scene.background = new THREE.Color( envSettings.backgroundColor );
				scene.fog = envSettings.fogEnabled ? new THREE.Fog( envSettings.fogColor, envSettings.fogNear, envSettings.fogFar ) : null;
				fillLight1.color.set( envSettings.hemiSkyColor );
				fillLight1.groundColor.set( envSettings.hemiGroundColor );
				fillLight1.intensity = envSettings.hemiIntensity;
				directionalLight.color.set( envSettings.sunColor );
				directionalLight.intensity = envSettings.sunIntensity;
				directionalLight.position.set( envSettings.sunPosX, envSettings.sunPosY, envSettings.sunPosZ );
				ambientLight.color.set( envSettings.ambientColor );
				ambientLight.intensity = envSettings.ambientIntensity;
				renderer.toneMapping = toneMappingOptions[ envSettings.toneMapping ];
				renderer.toneMappingExposure = envSettings.exposure;
				if ( world ) world.gravity.set( 0, -envSettings.gravity, 0 );
				if ( playerGroundContact ) playerGroundContact.friction = envSettings.friction;
				if ( playerBody ) { playerBody.mass = envSettings.playerMass; playerBody.updateMassProperties(); }
			}

			const toneMappingOptions = {
				'None': THREE.NoToneMapping,
				'Linear': THREE.LinearToneMapping,
				'Reinhard': THREE.ReinhardToneMapping,
				'Cineon': THREE.CineonToneMapping,
				'ACESFilmic': THREE.ACESFilmicToneMapping
			};

			document.addEventListener( 'keydown', ( event ) => {

				keyStates[ event.code ] = true;

			} );

			document.addEventListener( 'keyup', ( event ) => {

				keyStates[ event.code ] = false;

			} );

			container.addEventListener( 'mousedown', () => {

				document.body.requestPointerLock();

			} );

			document.body.addEventListener( 'mousemove', ( event ) => {

				if ( document.pointerLockElement === document.body ) {

					camera.rotation.y -= event.movementX / 500;
					camera.rotation.x -= event.movementY / 500;

				}

			} );

			/** Mobile touch controls */
			const touchState = {
				active: false, startX: 0, startY: 0, currentX: 0, currentY: 0,
				lastX: 0, lastY: 0, isHolding: false, holdThreshold: 15,
				touchStartTime: 0, holdDelay: 100
			};
			let mobileMovingForward = false;
			const touchSensitivity = 0.003;
			const isTouchDevice = isMobile || ( 'ontouchstart' in window ) || ( navigator.maxTouchPoints > 0 );
			
			container.addEventListener( 'touchstart', ( e ) => {
				e.preventDefault();
				if ( e.touches.length === 1 ) {
					const t = e.touches[ 0 ];
					touchState.active = true;
					touchState.startX = touchState.currentX = touchState.lastX = t.clientX;
					touchState.startY = touchState.currentY = touchState.lastY = t.clientY;
					touchState.isHolding = true;
					touchState.touchStartTime = performance.now();
					mobileMovingForward = false;
				}
			}, { passive: false } );
			
			container.addEventListener( 'touchmove', ( e ) => {
				e.preventDefault();
				if ( !touchState.active || e.touches.length !== 1 ) return;
				const t = e.touches[ 0 ];
				touchState.currentX = t.clientX;
				touchState.currentY = t.clientY;
				const deltaX = touchState.currentX - touchState.lastX;
				const deltaY = touchState.currentY - touchState.lastY;
				const totalMovement = Math.hypot( touchState.currentX - touchState.startX, touchState.currentY - touchState.startY );
				
				if ( totalMovement > touchState.holdThreshold ) {
					touchState.isHolding = false;
					mobileMovingForward = false;
					camera.rotation.y -= deltaX * touchSensitivity;
					camera.rotation.x -= deltaY * touchSensitivity;
					camera.rotation.x = Math.max( -Math.PI / 2, Math.min( Math.PI / 2, camera.rotation.x ) );
				} else if ( performance.now() - touchState.touchStartTime > touchState.holdDelay && touchState.isHolding ) {
					mobileMovingForward = true;
				}
				touchState.lastX = touchState.currentX;
				touchState.lastY = touchState.currentY;
			}, { passive: false } );
			
			container.addEventListener( 'touchend', ( e ) => {
				e.preventDefault();
				touchState.active = touchState.isHolding = mobileMovingForward = false;
			}, { passive: false } );
			
			container.addEventListener( 'touchcancel', () => {
				touchState.active = touchState.isHolding = mobileMovingForward = false;
			} );
			
			function updateMobileInput() {
				if ( touchState.active && touchState.isHolding && performance.now() - touchState.touchStartTime > touchState.holdDelay ) {
					mobileMovingForward = true;
				}
			}
			
			if ( isTouchDevice ) {
				document.querySelector( '.desktop-controls' ).style.display = 'none';
				document.querySelector( '.mobile-controls' ).style.display = 'inline';
			}

			window.addEventListener( 'resize', onWindowResize );

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
				composer.setSize( window.innerWidth, window.innerHeight );
				ssaoPass.setSize( Math.floor( window.innerWidth / 2 ), Math.floor( window.innerHeight / 2 ) );
				bloomPass.setSize( window.innerWidth, window.innerHeight );
				masterPostPass.uniforms[ 'resolution' ].value.set( window.innerWidth, window.innerHeight );
			}

			function createColliderVisualization() {
				if ( colliderVisualization ) scene.remove( colliderVisualization );
				const group = new THREE.Group();
				const radius = PLAYER_RADIUS;
				const cylHeight = PLAYER_HEIGHT - ( PLAYER_RADIUS * 2 );
				const lineMat = new THREE.LineBasicMaterial( { color: 0xff0000, transparent: true, opacity: 0.9 } );
				
				const cylGeo = new THREE.CylinderGeometry( radius, radius, cylHeight, 16, 1 );
				group.add( new THREE.LineSegments( new THREE.EdgesGeometry( cylGeo ), lineMat ) );
				
				const topGeo = new THREE.SphereGeometry( radius, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2 );
				const topLines = new THREE.LineSegments( new THREE.EdgesGeometry( topGeo ), lineMat );
				topLines.position.y = cylHeight / 2;
				group.add( topLines );
				
				const botGeo = new THREE.SphereGeometry( radius, 16, 8, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2 );
				const botLines = new THREE.LineSegments( new THREE.EdgesGeometry( botGeo ), lineMat );
				botLines.position.y = -cylHeight / 2;
				group.add( botLines );
				
				const topMarker = new THREE.Mesh( new THREE.CircleGeometry( radius * 0.25, 16 ), new THREE.MeshBasicMaterial( { color: 0x00ff00, side: THREE.DoubleSide, transparent: true, opacity: 0.9 } ) );
				topMarker.rotation.x = -Math.PI / 2;
				topMarker.position.y = PLAYER_HEIGHT / 2;
				group.add( topMarker );
				
				const botMarker = new THREE.Mesh( new THREE.CircleGeometry( radius * 0.25, 16 ), new THREE.MeshBasicMaterial( { color: 0x0000ff, side: THREE.DoubleSide, transparent: true, opacity: 0.9 } ) );
				botMarker.rotation.x = -Math.PI / 2;
				botMarker.position.y = -PLAYER_HEIGHT / 2;
				group.add( botMarker );
				
				colliderVisualization = group;
				colliderVisualization.name = 'PlayerColliderVisualization';
				scene.add( colliderVisualization );
			}

			function updateColliderVisualization() {
				if ( !playerBody || !colliderVisualization ) return;
				colliderVisualization.position.set( playerBody.position.x, playerBody.position.y, playerBody.position.z );
			}

			const targetVelocity = new THREE.Vector3( 0, 0, 0 );
			const JUMP_DEBOUNCE_SEC = 1;
			let jumpCooldownRemaining = 0;
			
			const _rayFrom = new CANNON.Vec3();
			const _rayTo = new CANNON.Vec3();
			const _rayResult = new CANNON.RaycastResult();
			
			function checkGroundContact() {
				if ( !playerBody ) return;
				_rayFrom.set( playerBody.position.x, playerBody.position.y, playerBody.position.z );
				_rayTo.set( playerBody.position.x, playerBody.position.y - PLAYER_HEIGHT / 2 - 0.2, playerBody.position.z );
				world.raycastClosest( _rayFrom, _rayTo, {}, _rayResult );
				playerOnFloor = _rayResult.hasHit && _rayResult.distance < PLAYER_HEIGHT / 2 + 0.15;
			}

			const _inputDirection = new THREE.Vector3();
			const _currentHorizontalVel = new THREE.Vector3();
			const _velocityDiff = new THREE.Vector3();
			
			function applyPlayerMovement( deltaTime ) {
				if ( !playerBody ) return;
				jumpCooldownRemaining = Math.max( 0, jumpCooldownRemaining - deltaTime );
				_inputDirection.set( 0, 0, 0 );
				
				if ( keyStates[ 'KeyW' ] ) { const f = getForwardVector(); _inputDirection.x += f.x; _inputDirection.z += f.z; }
				if ( keyStates[ 'KeyS' ] ) { const f = getForwardVector(); _inputDirection.x -= f.x; _inputDirection.z -= f.z; }
				if ( keyStates[ 'KeyA' ] ) { const s = getSideVector(); _inputDirection.x -= s.x; _inputDirection.z -= s.z; }
				if ( keyStates[ 'KeyD' ] ) { const s = getSideVector(); _inputDirection.x += s.x; _inputDirection.z += s.z; }
				if ( mobileMovingForward ) { const f = getForwardVector(); _inputDirection.x += f.x; _inputDirection.z += f.z; }
				
				const hasInput = _inputDirection.lengthSq() > 0.001;
				if ( hasInput ) _inputDirection.normalize();
				
				_currentHorizontalVel.set( playerBody.velocity.x, 0, playerBody.velocity.z );
				hasInput ? targetVelocity.copy( _inputDirection ).multiplyScalar( envSettings.moveSpeed ) : targetVelocity.set( 0, 0, 0 );
				
				const accelRate = playerOnFloor ? envSettings.acceleration : envSettings.acceleration * envSettings.airControl;
				const decelRate = playerOnFloor ? envSettings.deceleration : envSettings.deceleration * envSettings.airControl * 0.5;
				_velocityDiff.subVectors( targetVelocity, _currentHorizontalVel );
				const velocityDiffLength = _velocityDiff.length();
				
				if ( velocityDiffLength > 0.01 ) {
					const rate = hasInput ? accelRate : decelRate;
					const maxChange = rate * deltaTime;
					if ( velocityDiffLength <= maxChange || accelRate > 150 ) {
						playerBody.velocity.x = targetVelocity.x;
						playerBody.velocity.z = targetVelocity.z;
					} else {
						_velocityDiff.normalize().multiplyScalar( maxChange );
						playerBody.velocity.x += _velocityDiff.x;
						playerBody.velocity.z += _velocityDiff.z;
					}
				}
				
				const horizontalSpeed = Math.hypot( playerBody.velocity.x, playerBody.velocity.z );
				if ( horizontalSpeed > envSettings.moveSpeed ) {
					const scale = envSettings.moveSpeed / horizontalSpeed;
					playerBody.velocity.x *= scale;
					playerBody.velocity.z *= scale;
				}
				
				if ( keyStates[ 'Space' ] && playerOnFloor && jumpCooldownRemaining <= 0 ) {
					playerBody.velocity.y = envSettings.jumpVelocity;
					keyStates[ 'Space' ] = false;
					jumpCooldownRemaining = JUMP_DEBOUNCE_SEC;
				}
			}

			const smoothedCameraPos = new THREE.Vector3( SPAWN_POSITION.x, SPAWN_POSITION.y, SPAWN_POSITION.z );
			const _targetCameraPos = new THREE.Vector3();
			const _playerCenter = new THREE.Vector3();
			const _forward = new THREE.Vector3();
			const _offset = new THREE.Vector3();
			const _lookAtTarget = new THREE.Vector3();
			
			/** Physics sub-steps: limit to prevent "spiral of death" when frames drop */
			const PHYSICS_MAX_SUBSTEPS = 2;
			
			function updatePhysics( deltaTime ) {
				if ( !playerBody ) return;
				checkGroundContact();
				applyPlayerMovement( deltaTime );
				world.step( PHYSICS_TIMESTEP, deltaTime, PHYSICS_MAX_SUBSTEPS );
				updateColliderVisualization();
				
				const playerPos = playerBody.position;
				const eyeHeight = PLAYER_HEIGHT / 2 + PLAYER_EYE_HEIGHT - PLAYER_HEIGHT;
				_targetCameraPos.set( playerPos.x, playerPos.y + eyeHeight, playerPos.z );
				smoothedCameraPos.lerp( _targetCameraPos, Math.min( 1, deltaTime * envSettings.cameraSmoothing ) );
				
				if ( cameraMode === 'firstPerson' ) {
					camera.position.copy( smoothedCameraPos );
				} else {
					_playerCenter.copy( smoothedCameraPos );
					camera.getWorldDirection( _forward );
					_forward.y = 0;
					_forward.normalize();
					_offset.copy( _forward ).multiplyScalar( -envSettings.thirdPersonDistance );
					_offset.y = envSettings.thirdPersonHeight;
					camera.position.copy( _playerCenter ).add( _offset );
					_lookAtTarget.copy( _playerCenter );
					_lookAtTarget.y += envSettings.thirdPersonAngle * 2;
					camera.lookAt( _lookAtTarget );
				}
			}

			function createTrimeshFromGeometry( geometry, scale = new THREE.Vector3( 1, 1, 1 ) ) {
				const position = geometry.attributes.position;
				const vertices = [], indices = [];
				for ( let i = 0; i < position.count; i++ ) {
					vertices.push( position.getX( i ) * scale.x, position.getY( i ) * scale.y, position.getZ( i ) * scale.z );
				}
				if ( geometry.index ) {
					for ( let i = 0; i < geometry.index.count; i++ ) indices.push( geometry.index.getX( i ) );
				} else {
					for ( let i = 0; i < position.count; i++ ) indices.push( i );
				}
				return new CANNON.Trimesh( vertices, indices );
			}

			function addCollisionMeshToWorld( mesh ) {
				mesh.traverse( ( child ) => {
					if ( child.isMesh && child.geometry ) {
						child.updateMatrixWorld( true );
						const worldPos = new THREE.Vector3();
						const worldQuat = new THREE.Quaternion();
						const worldScale = new THREE.Vector3();
						child.matrixWorld.decompose( worldPos, worldQuat, worldScale );
						
						/** 
						 * Optimization: Reference geometry directly instead of cloning.
						 * Pass scale to createTrimeshFromGeometry to apply during vertex extraction.
						 * This avoids doubling RAM usage on high-poly collision meshes.
						 */
						const trimesh = createTrimeshFromGeometry( child.geometry, worldScale );
						const body = new CANNON.Body( {
							mass: 0,
							material: groundMaterial,
							position: new CANNON.Vec3( worldPos.x, worldPos.y, worldPos.z ),
							quaternion: new CANNON.Quaternion( worldQuat.x, worldQuat.y, worldQuat.z, worldQuat.w )
						} );
						body.addShape( trimesh );
						world.addBody( body );
					}
				} );
			}

			function getForwardVector() {
				camera.getWorldDirection( playerDirection );
				playerDirection.y = 0;
				playerDirection.normalize();
				return playerDirection;
			}

			function getSideVector() {
				camera.getWorldDirection( playerDirection );
				playerDirection.y = 0;
				playerDirection.normalize();
				playerDirection.cross( camera.up );
				return playerDirection;
			}

			let collisionWireframe = null;
			let colliderVisualization = null;

			const loader = new GLTFLoader();
			const loadingInfo = document.getElementById( 'info' );
			const originalInfoText = loadingInfo.innerHTML;
			loadingInfo.innerHTML = 'Loading model...';

			loader.load( 'maptest2-compressed.glb',
				( gltf ) => {
					loadingInfo.innerHTML = originalInfoText;
					scene.add( gltf.scene );

					let collisionMesh = null;
					const collisionNameSet = new Set( [ 'collisionmesh', 'collision', 'collision1' ] );

				gltf.scene.traverse( ( child ) => {
					if ( child.isMesh ) {
						child.castShadow = !isMobile; // Disable shadow casting on mobile
						child.receiveShadow = !isMobile; // Disable shadow receiving on mobile
						if ( child.material?.map ) child.material.map.anisotropy = isMobile ? 1 : 4;
						child.frustumCulled = true;
					}
					/** Hide flame objects */
					if ( child.name && child.name.toLowerCase().includes( 'flame' ) ) {
						child.visible = false;
					}
					if ( !collisionMesh && child.name ) {
						const nameLower = child.name.toLowerCase();
						if ( collisionNameSet.has( nameLower ) || nameLower.includes( 'collision' ) ) collisionMesh = child;
					}
				} );

					if ( collisionMesh ) {
						let totalTriangles = 0, hasValidGeometry = false;
						collisionMesh.traverse( ( child ) => {
							if ( child.isMesh && child.geometry ) {
								hasValidGeometry = true;
								const vertexCount = child.geometry.attributes?.position?.count || 0;
								totalTriangles += vertexCount >= 3 ? Math.floor( vertexCount / 3 ) : 0;
							}
						} );
						
						if ( !hasValidGeometry || totalTriangles === 0 ) {
							addCollisionMeshToWorld( gltf.scene );
						} else {
							addCollisionMeshToWorld( collisionMesh );
							collisionMesh.visible = false;
							
							if ( !isMobile && envSettings.showCollisionWireframe ) {
								requestAnimationFrame( () => {
									collisionWireframe = new THREE.Group();
									collisionWireframe.name = 'CollisionWireframe';
									collisionMesh.traverse( ( child ) => {
										if ( child.isMesh && child.geometry ) {
											const wireMat = new THREE.MeshBasicMaterial( { color: 0x00ff00, wireframe: true, transparent: true, opacity: 0.5, depthTest: true, depthWrite: false } );
											const wireMesh = new THREE.Mesh( child.geometry.clone(), wireMat );
											wireMesh.position.copy( child.position );
											wireMesh.rotation.copy( child.rotation );
											wireMesh.scale.copy( child.scale );
											collisionWireframe.add( wireMesh );
										}
									} );
									scene.add( collisionWireframe );
									collisionWireframe.visible = envSettings.showCollisionWireframe;
								} );
							}
						}
					} else {
						addCollisionMeshToWorld( gltf.scene );
					}

					const spawnPoint = gltf.scene.getObjectByName( 'SpawnPoint' );
					if ( spawnPoint ) {
						const spawnPos = new THREE.Vector3();
						spawnPoint.getWorldPosition( spawnPos );
						playerBody.position.set( spawnPos.x, spawnPos.y, spawnPos.z );
						playerBody.velocity.set( 0, 0, 0 );
						SPAWN_POSITION.x = spawnPos.x;
						SPAWN_POSITION.y = spawnPos.y;
						SPAWN_POSITION.z = spawnPos.z;
						spawnPoint.visible = false;
					}

					applySettings();

					requestAnimationFrame( () => {
						createColliderVisualization();
						if ( colliderVisualization ) colliderVisualization.visible = envSettings.showColliderVisualization;
					} );

					cameraMode = envSettings.cameraMode;
					createGUI(); // Create GUI for both mobile and desktop
				},
				( progress ) => {
					if ( progress.lengthComputable ) loadingInfo.innerHTML = `Loading model... ${ Math.round( progress.loaded / progress.total * 100 ) }%`;
				},
				( error ) => {
					console.error( 'Error loading model:', error );
					loadingInfo.innerHTML = 'Error loading model. Check console.';
				}
			);




			function createGUI() {
				const gui = new GUI( { width: isMobile ? 260 : 280, title: 'Environment Settings' } );
				// Keep GUI open on mobile as requested

				const skyFolder = gui.addFolder( 'Sky & Background' );
				skyFolder.addColor( envSettings, 'backgroundColor' ).name( 'Background' ).onChange( ( v ) => { scene.background = new THREE.Color( v ); saveSettings(); } );

				const fogFolder = gui.addFolder( 'Fog' );
				fogFolder.add( envSettings, 'fogEnabled' ).name( 'Enabled' ).onChange( ( v ) => { scene.fog = v ? new THREE.Fog( envSettings.fogColor, envSettings.fogNear, envSettings.fogFar ) : null; saveSettings(); } );
				fogFolder.addColor( envSettings, 'fogColor' ).name( 'Color' ).onChange( ( v ) => { if ( scene.fog ) scene.fog.color.set( v ); saveSettings(); } );
				fogFolder.add( envSettings, 'fogNear', 0, 100, 1 ).name( 'Near' ).onChange( ( v ) => { if ( scene.fog ) scene.fog.near = v; saveSettings(); } );
				fogFolder.add( envSettings, 'fogFar', 10, 500, 1 ).name( 'Far' ).onChange( ( v ) => { if ( scene.fog ) scene.fog.far = v; saveSettings(); } );

				const hemiFolder = gui.addFolder( 'Hemisphere Light' );
				hemiFolder.addColor( envSettings, 'hemiSkyColor' ).name( 'Sky' ).onChange( ( v ) => { fillLight1.color.set( v ); saveSettings(); } );
				hemiFolder.addColor( envSettings, 'hemiGroundColor' ).name( 'Ground' ).onChange( ( v ) => { fillLight1.groundColor.set( v ); saveSettings(); } );
				hemiFolder.add( envSettings, 'hemiIntensity', 0, 5, 0.1 ).name( 'Intensity' ).onChange( ( v ) => { fillLight1.intensity = v; saveSettings(); } );

				const sunFolder = gui.addFolder( 'Sun Light' );
				sunFolder.addColor( envSettings, 'sunColor' ).name( 'Color' ).onChange( ( v ) => { directionalLight.color.set( v ); saveSettings(); } );
				sunFolder.add( envSettings, 'sunIntensity', 0, 10, 0.1 ).name( 'Intensity' ).onChange( ( v ) => { directionalLight.intensity = v; saveSettings(); } );
				sunFolder.add( envSettings, 'sunPosX', -50, 50, 1 ).name( 'X' ).onChange( ( v ) => { directionalLight.position.x = v; saveSettings(); } );
				sunFolder.add( envSettings, 'sunPosY', 0, 100, 1 ).name( 'Y' ).onChange( ( v ) => { directionalLight.position.y = v; saveSettings(); } );
				sunFolder.add( envSettings, 'sunPosZ', -50, 50, 1 ).name( 'Z' ).onChange( ( v ) => { directionalLight.position.z = v; saveSettings(); } );

				const ambientFolder = gui.addFolder( 'Ambient Light' );
				ambientFolder.addColor( envSettings, 'ambientColor' ).name( 'Color' ).onChange( ( v ) => { ambientLight.color.set( v ); saveSettings(); } );
				ambientFolder.add( envSettings, 'ambientIntensity', 0, 3, 0.1 ).name( 'Intensity' ).onChange( ( v ) => { ambientLight.intensity = v; saveSettings(); } );

				const renderFolder = gui.addFolder( 'Renderer' );
				renderFolder.add( envSettings, 'toneMapping', Object.keys( toneMappingOptions ) ).name( 'Tone Mapping' ).onChange( ( v ) => { renderer.toneMapping = toneMappingOptions[ v ]; saveSettings(); } );
				renderFolder.add( envSettings, 'exposure', 0, 3, 0.05 ).name( 'Exposure' ).onChange( ( v ) => { renderer.toneMappingExposure = v; saveSettings(); } );

				const movementFolder = gui.addFolder( 'Movement & Physics' );
				movementFolder.add( envSettings, 'moveSpeed', 1, 100, 1 ).name( 'Speed' ).onChange( saveSettings );
				movementFolder.add( envSettings, 'acceleration', 10, 500, 10 ).name( 'Acceleration' ).onChange( saveSettings );
				movementFolder.add( envSettings, 'deceleration', 1, 100, 1 ).name( 'Deceleration' ).onChange( saveSettings );
				movementFolder.add( envSettings, 'gravity', 5, 50, 1 ).name( 'Gravity' ).onChange( ( v ) => { world.gravity.set( 0, -v, 0 ); saveSettings(); } );
				movementFolder.add( envSettings, 'jumpVelocity', 1, 15, 0.5 ).name( 'Jump' ).onChange( saveSettings );
				movementFolder.add( envSettings, 'friction', 0, 1, 0.01 ).name( 'Friction' ).onChange( ( v ) => { playerGroundContact.friction = v; saveSettings(); } );
				movementFolder.add( envSettings, 'airControl', 0, 1, 0.05 ).name( 'Air Control' ).onChange( saveSettings );
				movementFolder.add( envSettings, 'playerMass', 1, 100, 1 ).name( 'Mass' ).onChange( ( v ) => { playerBody.mass = v; playerBody.updateMassProperties(); saveSettings(); } );
				movementFolder.add( envSettings, 'cameraSmoothing', 1, 30, 1 ).name( 'Cam Smoothing' ).onChange( saveSettings );

				const debugFolder = gui.addFolder( 'Debug' );
				debugFolder.add( envSettings, 'showCollisionWireframe' ).name( 'Collision Wireframe' ).onChange( ( v ) => { if ( collisionWireframe ) collisionWireframe.visible = v; saveSettings(); } );
				debugFolder.add( envSettings, 'showColliderVisualization' ).name( 'Player Collider' ).onChange( ( v ) => { if ( colliderVisualization ) colliderVisualization.visible = v; saveSettings(); } );

				const cameraFolder = gui.addFolder( 'Camera' );
				cameraFolder.add( envSettings, 'cameraMode', [ 'firstPerson', 'thirdPerson' ] ).name( 'Mode' ).onChange( ( v ) => { cameraMode = v; saveSettings(); } );
				cameraFolder.add( envSettings, 'thirdPersonDistance', 2, 15, 0.5 ).name( '3P Distance' ).onChange( saveSettings );
				cameraFolder.add( envSettings, 'thirdPersonHeight', 0, 5, 0.1 ).name( '3P Height' ).onChange( saveSettings );
				cameraFolder.add( envSettings, 'thirdPersonAngle', -0.5, 0.5, 0.05 ).name( '3P Angle' ).onChange( saveSettings );

				const waterFolder = gui.addFolder( 'Water' );
				waterFolder.addColor( waterParams, 'color' ).name( 'Color' ).onChange( ( v ) => { if ( water?.material ) water.material.uniforms[ 'color' ].value.set( v ); } );
				waterFolder.add( waterParams, 'scale', 1, 10, 0.5 ).name( 'Scale' ).onChange( ( v ) => { if ( water?.material ) water.material.uniforms[ 'config' ].value.w = v; } );
				waterFolder.add( waterParams, 'flowX', -2, 2, 0.1 ).name( 'Flow X' ).onChange( ( v ) => { if ( water?.material ) water.material.uniforms[ 'flowDirection' ].value.x = v; } );
				waterFolder.add( waterParams, 'flowY', -2, 2, 0.1 ).name( 'Flow Y' ).onChange( ( v ) => { if ( water?.material ) water.material.uniforms[ 'flowDirection' ].value.y = v; } );
				waterParams.waterHeight = 0;
				waterFolder.add( waterParams, 'waterHeight', -10, 10, 0.1 ).name( 'Height' ).onChange( ( v ) => { if ( water ) water.position.y = v; } );
				waterFolder.close();

				const postFolder = gui.addFolder( 'Post-Processing' );

				const ssaoFolder = postFolder.addFolder( 'SSAO' );
				ssaoFolder.add( postProcessingSettings, 'ssaoEnabled' ).name( 'Enabled' ).onChange( ( v ) => { ssaoPass.enabled = v; } );
				ssaoFolder.add( postProcessingSettings, 'ssaoKernelRadius', 1, 32, 1 ).name( 'Radius' ).onChange( ( v ) => { ssaoPass.kernelRadius = v; } );
				ssaoFolder.add( postProcessingSettings, 'ssaoMinDistance', 0.001, 0.02, 0.001 ).name( 'Min Dist' ).onChange( ( v ) => { ssaoPass.minDistance = v; } );
				ssaoFolder.add( postProcessingSettings, 'ssaoMaxDistance', 0.01, 0.3, 0.01 ).name( 'Max Dist' ).onChange( ( v ) => { ssaoPass.maxDistance = v; } );

				const bloomFolder = postFolder.addFolder( 'Bloom' );
				bloomFolder.add( postProcessingSettings, 'bloomEnabled' ).name( 'Enabled' ).onChange( ( v ) => { bloomPass.enabled = v; } );
				bloomFolder.add( postProcessingSettings, 'bloomStrength', 0, 2, 0.01 ).name( 'Strength' ).onChange( ( v ) => { bloomPass.strength = v; } );
				bloomFolder.add( postProcessingSettings, 'bloomRadius', 0, 1, 0.01 ).name( 'Radius' ).onChange( ( v ) => { bloomPass.radius = v; } );
				bloomFolder.add( postProcessingSettings, 'bloomThreshold', 0, 1, 0.01 ).name( 'Threshold' ).onChange( ( v ) => { bloomPass.threshold = v; } );

				const filmFolder = postFolder.addFolder( 'Film Grain' );
				filmFolder.add( postProcessingSettings, 'filmEnabled' ).name( 'Enabled' ).onChange( ( v ) => { masterPostPass.uniforms[ 'grainEnabled' ].value = v; } );
				filmFolder.add( postProcessingSettings, 'filmNoiseIntensity', 0, 1, 0.01 ).name( 'Intensity' ).onChange( ( v ) => { masterPostPass.uniforms[ 'grainIntensity' ].value = v; } );

				const vignetteFolder = postFolder.addFolder( 'Vignette' );
				vignetteFolder.add( postProcessingSettings, 'vignetteEnabled' ).name( 'Enabled' ).onChange( ( v ) => { masterPostPass.uniforms[ 'vignetteEnabled' ].value = v; } );
				vignetteFolder.add( postProcessingSettings, 'vignetteOffset', 0.5, 2.0, 0.05 ).name( 'Offset' ).onChange( ( v ) => { masterPostPass.uniforms[ 'vignetteOffset' ].value = v; } );
				vignetteFolder.add( postProcessingSettings, 'vignetteDarkness', 0.5, 3.0, 0.1 ).name( 'Darkness' ).onChange( ( v ) => { masterPostPass.uniforms[ 'vignetteDarkness' ].value = v; } );

				const tiltShiftFolder = postFolder.addFolder( 'Tilt-Shift' );
				tiltShiftFolder.add( postProcessingSettings, 'tiltShiftEnabled' ).name( 'Enabled' ).onChange( ( v ) => { masterPostPass.uniforms[ 'tiltShiftEnabled' ].value = v; } );
				tiltShiftFolder.add( postProcessingSettings, 'tiltShiftFocusY', 0, 1, 0.01 ).name( 'Focus Y' ).onChange( ( v ) => { masterPostPass.uniforms[ 'focusY' ].value = v; } );
				tiltShiftFolder.add( postProcessingSettings, 'tiltShiftFocusWidth', 0.1, 0.8, 0.01 ).name( 'Width' ).onChange( ( v ) => { masterPostPass.uniforms[ 'focusWidth' ].value = v; } );
				tiltShiftFolder.add( postProcessingSettings, 'tiltShiftBlurAmount', 0, 6, 0.1 ).name( 'Blur' ).onChange( ( v ) => { masterPostPass.uniforms[ 'blurAmount' ].value = v; } );

				const lutFolder = postFolder.addFolder( 'LUT' );
				lutFolder.add( postProcessingSettings, 'lutEnabled' ).name( 'Enabled' ).onChange( ( v ) => { if ( lutPass ) lutPass.enabled = v; } );
				lutFolder.add( postProcessingSettings, 'lutIntensity', 0, 1, 0.01 ).name( 'Intensity' ).onChange( ( v ) => { if ( lutPass ) lutPass.intensity = v; } );

				debugFolder.add( { reset: () => {
					Object.assign( envSettings, defaultEnvSettings );
					applySettings();
					if ( collisionWireframe ) collisionWireframe.visible = envSettings.showCollisionWireframe;
					if ( colliderVisualization ) colliderVisualization.visible = envSettings.showColliderVisualization;
					cameraMode = envSettings.cameraMode;
					gui.controllersRecursive().forEach( c => c.updateDisplay() );
					saveSettings();
				} }, 'reset' ).name( 'Reset Defaults' );

				[ fogFolder, hemiFolder, sunFolder, ambientFolder, renderFolder, movementFolder, debugFolder, postFolder ].forEach( f => f.close() );
			}

			function teleportPlayerIfOob() {
				if ( playerBody.position.y <= -25 ) {
					playerBody.position.set( SPAWN_POSITION.x, SPAWN_POSITION.y, SPAWN_POSITION.z );
					playerBody.velocity.set( 0, 0, 0 );
					camera.rotation.set( 0, 0, 0 );
				}
			}

			function animate() {
				const deltaTime = Math.min( 0.05, clock.getDelta() );
				updateMobileInput();
				updatePhysics( deltaTime );
				teleportPlayerIfOob();
				masterPostPass.uniforms[ 'time' ].value += deltaTime;
				composer.render( deltaTime );
				stats.update();
				coordsDisplay.innerHTML = `X: ${camera.position.x.toFixed(2)}<br>Y: ${camera.position.y.toFixed(2)}<br>Z: ${camera.position.z.toFixed(2)}`;
			}



		</script>
</body>

</html>